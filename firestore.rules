/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a security model that balances open access for public data
 * with strict ownership and authorization checks for user-specific and sensitive information.
 *
 * Data Structure:
 * - /users/{userId}: Stores personal user data, accessible only to the owner.
 * - /parkingSlots/{parkingSlotId}: Contains public parking slot information, readable by all.
 * - /reservations/{reservationId}: Stores reservation data, accessible only with authorization.
 * - /violations/{violationId}: Stores parking violation data, create restricted to authorized clients.
 * - /feedback/{feedbackId}: Stores user feedback, create open to all clients.
 *
 * Key Security Decisions:
 * - Users can only read and write their own data under /users/{userId}.
 * - Listing of users is disallowed to prevent enumeration.
 * - Public read access is granted to /parkingSlots/{parkingSlotId}.
 * - Write access to violations are restricted to server/admin.
 * - Write access to feedback are open to all clients.
 *
 * Denormalization for Authorization:
 * - Violations do not denormalize any data for authorization, create access is restricted.
 *
 * Structural Segregation:
 * - Public and private data is separated into different collections to optimize list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read and write their own user data.
     * @path /users/{userId}
     * @allow (create, update, delete, get, list) if the user is signed in and the requested userId matches the authenticated user's UID.
     *   Example: A user with UID 'user123' can create, update, delete, get and list data at /users/user123.
     * @deny (create, update, delete, get, list) if the user is not signed in or the requested userId does not match the authenticated user's UID.
     *   Example: A user with UID 'user123' cannot access data at /users/user456.
     * @principle Enforces user-ownership for all write operations.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to parking slot information.
     * @path /parkingSlots/{parkingSlotId}
     * @allow (get, list) any unauthenticated client can read any parking slot.
     *   Example: Any user, signed in or not, can read the details of a parking slot.
     * @deny (create, update, delete) all write operations are denied on parking slots.
     * @principle Allows public data to be read without authentication, while preventing unauthorized modifications.
     */
    match /parkingSlots/{parkingSlotId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows access to reservations, checking that the user matches the reservation's user ID.
     * @path /reservations/{reservationId}
     * @allow (create) any signed-in user can create.
     *   Example: A user can create a new reservation. The reservation data MUST include a userId field that matches the user's UID.
     * @allow (get, list) any signed-in user can get or list data.
     *   Example: A user can retrieve a reservation if the userId matches their UID.
     * @allow (update, delete) only if the user owns the data.
     *   Example: A user with UID 'user123' can update reservation data only when the reservation contains userId: 'user123'.
     * @deny (create, update, delete, get, list) if the user is not signed in.
     *   Example: An unauthenticated user cannot create, view, or modify any reservation.
     * @principle Enforces authorization by requiring the user to be the owner of the data to perform write operations.
     */
    match /reservations/{reservationId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(resource.data.userId);
    }

     /**
      * @description Restricts write access to violations. Read access is open.
      * @path /violations/{violationId}
      * @allow (get, list) any client, authenticated or unauthenticated, can read violation.
      *   Example: all clients can get, list violations.
      * @deny (create, update, delete) all client creations.
      *   Example: All users can not create violations.
      * @principle Restricts creating of violation reports to backend/admin processes.
      */
    match /violations/{violationId} {
        allow get, list: if true;
        allow create, update, delete: if false;
    }

    /**
     * @description Allows any user to create feedback.
     * @path /feedback/{feedbackId}
     * @allow (get, list, create) any user can create, get, list feedback.
     *   Example: all users, sign-in not required, can create feedback.
     * @deny (update, delete) all updates are denied.
     * @principle Open access for submitting feedback.
     */
    match /feedback/{feedbackId} {
      allow get, list, create: if true;
      allow update, delete: if false;
    }

  }

  // Helper function to determine if the user is signed in
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the document
  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

    // Helper function to determine if the user is the owner of the document and the document exists
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}